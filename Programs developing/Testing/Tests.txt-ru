====================================================================================================
Модульное тестирование в .NET Core и .NET Standard
https://docs.microsoft.com/ru-ru/dotnet/core/testing/?pivots=mstest
====================================================================================================
Типы тестов:
- функциональные тесты;
- интеграционные тесты;
- веб-тесты;
- нагрузочные тесты;
- модульные тесты.
----------------------------------------------------------------------------------------------------
Модульные тесты должны проверять только код, к которому у разработчика есть доступ. Они не должны затрагивать инфраструктуру. 
Инфраструктура включает базы данных, файловые системы и сетевые ресурсы.
Попробуйте не создавать зависимости в инфраструктуре при написании модульных тестов.
----------------------------------------------------------------------------------------------------
Почему именно модульные тесты?
- Меньше времени на выполнение функциональных тестов.
- Защита от регрессии.
- Исполняемая документация.
- Менее связанный код.
Характеристики хорошего модульного теста:
- Быстрый.
- Изолированный.
- Повторяемый.
- Самопроверяющий.
- Уместный.
----------------------------------------------------------------------------------------------------
Термины.
Заполнитель — это общий термин, который можно использовать для описания заглушки или макета объекта. 
Использование заглушки или макета зависит от контекста. Иными словами, заполнитель может быть заглушкой или макетом.
Макет. Макет объекта — это объект-заполнитель в системе, который решает, пройден ли модульный тест. 
Макет начинает существование как заполнитель, пока по нему не будет проведена проверка.
Заглушка — это управляемая замена существующей зависимости (или участника) в системе. С помощью заглушки можно 
протестировать код, не задействовав зависимость напрямую. По умолчанию заполнитель выступает как заглушка.
----------------------------------------------------------------------------------------------------
Имя теста должно состоять из трех частей:
- имя тестируемого метода;
- сценарий, в котором выполняется тестирование (действия);
- ожидаемое поведение при вызове сценария (результат).
Метод_Действия_Резульат()
Add_SingleNumber_ReturnsSameNumber()
Add_EmptyString_ReturnsZero()
----------------------------------------------------------------------------------------------------
В случае "магических" строк рекомендуется присваивать эти значения константам.
const string MAXIMUM_RESULT = "1001";
----------------------------------------------------------------------------------------------------
Избегайте объединения строк вручную и логических условий, таких как if, while, for, switch и т. д.
Если логика в тесте неизбежна, рекомендуется разбить тест на несколько тестов.
----------------------------------------------------------------------------------------------------
Если вам требуется аналогичный объект или состояние для тестов, лучше используйте вспомогательный метод, 
чем атрибуты установки и удаления, если они существуют.
В xUnit удалены SetUp и TearDown в версии 2.x.
----------------------------------------------------------------------------------------------------
При написании тестов попробуйте включить только одно проверочное утверждение в каждый тест. 
Общие подходы к использованию только одного проверочного утверждения включают следующее:
- Создание отдельного теста для каждого проверочного утверждения.
- Использование параметризованных тестов.
----------------------------------------------------------------------------------------------------
Закрытые методы никогда не существуют в изоляции. Рано или поздно у вас будет открытый метод, вызывающий закрытый 
метод в рамках его реализации. Вам следует думать о конечном результате открытого метода, который вызывает закрытый метод.
----------------------------------------------------------------------------------------------------
Используйте заглушки для статических ссылок.
Например, можно заключить код, который необходимо контролировать, в интерфейс, чтобы рабочий код зависел от этого интерфейса.
public interface IDateTimeProvider
{
    DayOfWeek DayOfWeek();
}
public int GetDiscountedPrice(int price, IDateTimeProvider dateTimeProvider)
{
    if(dateTimeProvider.DayOfWeek() == DayOfWeek.Tuesday)
    {
        return price / 2;
    }
    else
    {
        return price;
    }
}
Набор тестов теперь выглядит так.
public void GetDiscountedPrice_ByDefault_ReturnsFullPrice()
{
    var priceCalculator = new PriceCalculator();
    var dateTimeProviderStub = new Mock<IDateTimeProvider>();
    dateTimeProviderStub.Setup(dtp => dtp.DayOfWeek()).Returns(DayOfWeek.Monday);
    var actual = priceCalculator.GetDiscountedPrice(2, dateTimeProviderStub);
    Assert.Equals(2, actual);
}
public void GetDiscountedPrice_OnTuesday_ReturnsHalfPrice()
{
    var priceCalculator = new PriceCalculator();
    var dateTimeProviderStub = new Mock<IDateTimeProvider>();
    dateTimeProviderStub.Setup(dtp => dtp.DayOfWeek()).Returns(DayOfWeek.Tuesday);
    var actual = priceCalculator.GetDiscountedPrice(2, dateTimeProviderStub);
    Assert.Equals(1, actual);
}
----------------------------------------------------------------------------------------------------
