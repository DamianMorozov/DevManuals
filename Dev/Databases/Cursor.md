http://kbss.ru/blog/mssql/55.html


Курсоры в MSSQL - перебор выборки в цикле. 

Команды манипулирования данными SELECT, UPDATE, DELETE работают сразу с группами строк. Эти группы, вплоть до отдельных строк, можно выбрать с помощью опции WHERE. 
А если надо перебрать строки некоторой таблицы последовательно, одну за другой? На этот случай в языке SQL существуют курсоры. 
Курсор (current set of record) – временный набор строк, которые можно перебирать последовательно, с первой до последней.
При работе с курсорами используются следующие команды.
Объявление курсора:  DECLARE имя_курсора CURSOR FOR SELECT текст_запроса
Любой курсор создается на основе некоторого оператора SELECT.
Открытие курсора:  OPEN имя_курсора
Для того чтобы с помощью курсора можно было читать строки, его надо обязательно открыть.
Чтение следующей строки из курсора:  FETCH имя_курсора INTO список_переменных
Переменные в списке должны быть в том же количестве и того е типа, что и столбцы курсора. 
Глобальная переменная @@FETCH_STATUS принимает ненулевое значение, если строк в курсоре больше нет. Если же набор строк еще не исчерпан, то @@FETCH_STATUS равна нулю, и оператор FETCH перепишет значения полей из текущей строки в переменные. 
Закрытие курсора: CLOSE имя_курсора

Для удаления курсора из памяти используется команда:  DEALLOCATE имя_курсора

Для иллюстрации использования курсора создадим процедуру, которая будет выбирать данные из одной таблицы, перебирать их в курсоре анализируя, есть ли такие данные во второй таблице и вставлять в третью таблицу, если данные записи удовлетворяют определённым критериям.
create procedure [dbo].[myprocedure] as
declare @id  int
declare @qua int
declare @val varchar (500)
declare @nam varchar (500)
declare @cursor cursor  -- курсор
set @cursor = cursor scroll
for select index, quantity, value, name  from my_first_table where quantity>1
open @cursor  -- открываем курсор
fetch next from @cursor into @id, @qua, @val, @nam  -- выбираем первую строку
while @@fetch_status=0 begin -- выполняем в цикле перебор строк
  if not exists(select val from my_second_table where id=@id) begin
  insert into my_third_table (value, name) value(@val, @nam)  -- вставляем параметры в третью таблицу если условие соблюдается
  fetch next from @cursor into @id, @qua, @val, @nam  -- выбираем следующую строку
end
close @cursor
deallocate @cursor
